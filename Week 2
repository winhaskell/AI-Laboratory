演算法的複雜度分界

在寫程式的時候，會聽到有人說這些問題是NP-Complete問題，或說這些是P問題，那這到底是什麼東西？
其實這就是一套定義演算法複雜度的方法，今天我就想帶大家來聊聊這個艱澀但有趣的話題。

Turing Machine
我們先從 Turing machine（圖靈機）開始講起，Turing machine是現代電腦的基本雛型，是英國數學家圖靈（Alan Turing）於1936年提出的一種抽象計算模型，
這個計算模型在猜想上可以「計算所有在演算法中可計算的問題」，也就是可以解決人類所有可解的問題，這個猜想稱之為 Church–Turing thesis（thesis代表假設或猜想），
僅管目前還無法證明這個猜想，但是目前為止它幾乎是完全被接受的。

簡單的談一下 Turing machine的基本架構，首先我們需要一個磁帶，這一條磁帶上面可以一格一格的填入一些 symbols，這可以是單純的 0/1 symbols 
或者更多種類的 symbols，但這些 symbols 的數量必須是有限的，而這個symbols就可以當作我的輸入，接下來我需要一個讀寫頭，這個讀寫頭會在磁帶上
讀取或寫入 symbol，或左右移動，另外這個讀寫頭存有一個 state，這個 state 會隨著狀況改變，然後我就利用 symbol 和 state 來建立一個規則表，
舉個例子，譬如說：初始的 state 是 q0，如果讀寫頭在q0 的情況下讀到 symbol 0，就寫入 symbol 1，並且向右移動3格，並且改變 state q0為 q1
，... 等等，藉由可操作的規則來完成我們想做的運算，最後最重要的是它必須有一個 halt state 讓機器知道已經計算完畢了。Turing machine 不僅僅
在理論上可以做任何的計算，而更有價值的是 Turing machine 的架構是有辦法用物理的方式來製造的，所以才會有現代電腦這玩意兒。

說到電腦，更嚴謹地說，我們當今的電腦架構是比較接近 deterministic Turing machine (DTM)，與之對比的是 non-deterministic Turing machine (NTM)，
我來好好的解釋一下，deterministic 的中文稱為決定性，所以 non-deterministic 就是非決定性。

如果給予 Turing machine 某個 state 和某個 symbol 下，它的下一步如果只有一種可能，那我們就稱它為 deterministic Turing machine (DTM)，

所以上述的讀取頭每次就依照當下特定的 symbol 和 state 然後「決定」下一步應該要怎麼動作。

但是 non-deterministic Turing machine (NTM) 就不拘於此，針對某個 state 和某個 symbol 它的下一步可能會有很多種，
它會是一個分支，它可能同時要向右移3格，又同時要向左移動2格，所以你可以想像一下你的讀寫頭一分為二，然後再各自進行自己的任務，
這個分支可以有無限多個，只要最後有某個分支到達 halt state，我們就解完問題並停止計算，這就是 non-deterministic Turing machine (NTM)。

顯而易見的，DTM 只是 NTM 的特例，所以 NTM 比 DTM 擁有更快的計算速度，但這裡不要誤會喔！不管是 DTM 和 NTM 能解的問題是一樣多的，
而且在數學上可以將 NTM 的計算方式轉換成 DTM 的計算方式，他們差異點只是解決相同問題所用到的時間複雜度不一樣，不過這就很關鍵。




時間複雜度
接下來，我要開始切入正題，我們來聊聊時間複雜度吧！什麼是時間複雜度呢？
時間複雜度用來評估演算法需要花多少時間做計算，我們常用大Ｏ符號來描述，代表的是一個漸進的函數數量級上界，
舉個例子，假設我想要在一個有序的數列2,3,5,7,13,27中找到7的位置，最簡單的做法就是從第一個元素開始檢查起，如果不是元素7
就再找下一個，直到找到為止，所以最差的情形就是我一路找直到了最後一個元素，如果數列有Ｎ個元素，我們最差的情形就是做了Ｎ
次的比較，而每次做比較所花的時間是一個常數時間，因此這個演算法的上界將被 a×N 所界定，a為常數，所以這個演算法的時間複雜度為Ｏ(N)，

再舉個稍微難一點的例子：子集合加總問題，假設給予一組集合{−7,−3,−2,5,8}，然後問是否有一組子集合相加為0，怎麼做呢？
最簡單的做法就是，窮舉出所有可能的子集合然後相加驗證是否剛好為0，假設集合中有Ｎ個元素，我會有2N 種的子集合，而且要加總最多Ｎ
個元素，所以這個過程的時間複雜度為 Ｏ(N×(2^N))。特別提醒，以上的分析方式大致上是符合DTM和現代電腦的運作方式，一步接著一步
做（step-by-step），而NTM就不這麼分析問題，當然兩者看待同一個問題的時間複雜度就會不一樣。

剛剛有提到 Turing machine 可以解所有演算法問題，那如果我製造一台機器符合 Turing machine或者是我購買一台電腦，
是不是就可以躺著解所有的問題了，很可惜的，並不是的！我們剛剛有簡單的帶大家了解時間複雜度，我們知道每種演算法有其計算時間，
子集合加總問題的時間複雜度為Ｏ(N×(2^N))，如果今天很單純的，我的元素只有1000個，這個數量不過分吧！但大家試著計算一下1000×(21000)
就會發現這是一個天文數字，它大到縱使每個計算只需要0.00001秒，也需要遠遠超過地球年齡的時間才有辦法算完，因此這類問題就算是可解的，
也並不實際代表你可以解完，因為你必須考慮解問題要花多少時間。

所以現實面是只有在一個數量級時間以下的問題我們才好應付，這個數量級被稱為 polynomial time（多項式時間），用大Ｏ表示為Ｏ(N^k)，
剛剛上面提到的數列找元素問題，它得時間複雜度為Ｏ(N)，為 polynomial time，這是屬於好對付的問題，如果超過 polynomial time 
的問題我們稱為 intractable problem (難解的問題)。





